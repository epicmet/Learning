As the name says, this kind of scoping happens at lexing time, meaning when the compiler is analyzing and compiling the code from top to bottom and sees variable deceleration, it would make some bubbles or scopes based on where they are in lexing (or tokeninzing) time. As I said previously when the engine or compiler can not find a variable in the executing scope, they will go to the upper scopes (until the global scope) to find that reference to the variable.

A really important note here is that the Javascript compilers (thanks to people working on V8) does somewhat optimization JUST before compilation! And one of the key things about these optimization is that the compiler should know how the structure of the scope and the type of the variables are, so that it can optimize the things. If we somehow find ways to change the lexical scope after the lexing part (at runtime), we ruined the optimization that compiler did, and it would do all those things that it did again (with the new knowledge of the new lexical scope). So we lose some performance. You may think we can not do such things, but OH BOY there are things that we can do!

One of them is `eval`. With eval we can turn arbitary strings into actuall code! Something like this `eval("console.log('hi');")`. The way that eval does change the lexical scope is by simply executing code at runtime. The catch is this code can be generated by user input or something else that changes at runtime.

```js
var a = 3;

console.log(a); // 3

eval("a = 'HI';");

console.log(a); // "HI" !!
```

OR

```js
function foo(str, a) {
  eval(str);
  console.log(a, b);
}

var b = 3;

foo("var b = 5", 1); // 1, 5 !!
```

By default the decelerations inside an eval modifies the current lexical scope but in `strict mode` it would have its own scope meaning it does not change the scope it is executing in. But still using it is a really bad practice, specially for the optimization and performance stuff.

That one other thing is `with` keyword. The main idea of `with` is that you can access property of an object without the dot notation.

```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
};

console.log(obj.a);
console.log(obj.b);
console.log(obj.c);
/////// INSTEAD //////
with (obj) {
  console.log(a);
  console.log(b);
  console.log(c);
}
```

The bad things happen when you want to set a value for a property that does not exists on the target object.

```js
function foo(obj) {
  with (obj) {
    a = 2;
  }
}

const o1 = {
  a: 1,
};

const o2 = {
  b: 1,
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2  -> liked to global
```

The main reason for this leak is the same story as we discussed in the previous chapter about not finding the variable even in the global scope in LHS look ups (not in `strict mode`). Because the `with` keyword does not have its own scope (it's not a block scope) a `var` deceleration will not scoped to the `with` block instead it would scope to the containing function scope.

The `with` keyword is disallowed in `strict mode`.
